version: "3.3"

services: # la liste des services que l'on va utiliser dans docker compose
  frdev-api: # le nom du service. Pour le lancer, par exemple, on fera docker compose up -d frdev-api  (le -d pour le lancer en arrière plan, sinon il faut faire ctrl+c pour le stopper)
    build: . # le chemin vers le Dockerfile
    ports:
      - "8000:8000" # le port sur lequel on va accéder à l'application (A gauche : le port sur lequel on va accéder à l'application, à droite : le port sur lequel l'application est exposée dans le container)
    depends_on:
      - database # le service dont dépend le service frdev-api. Ici, on attend que le service database soit lancé avant de lancer le service frdev-api
    include:
      env_file:
        - ./.env # le fichier .env qui contient les variables d'environnement
    #volumes

  database:
    image: mysql:5.7 # l'image que l'on va utiliser pour le service database. On pourrait builder notre propre image, mais ici on va utiliser une image existante
    restart: always # on veut que le service database soit toujours lancé. Si ton serveur redémarre, le service database sera relancé automatiquement(sauf si tu fais un docker compose down !)
    ports:
      - "3306:3306"
    env_file:
      - ./.env
    volumes:
      - ./frapi-data:/var/lib/mysql # on va monter un volume pour que les données de la base de données soient persistantes.

  proxy:
    # admin@example.com  (pour se log sur l'interface d'admin)
    # changeme           (pour se log sur l'interface d'admin)
    image: "jc21/nginx-proxy-manager:latest"
    container_name: nginx-proxy-manager
    ports:
      - "80:80" # il faut que ce port soit accessible depuis l'extérieur pour que letsencrypt puisse vérifier que tu es bien le propriétaire du domaine
      - "81:81" # il faut que ce port soit accessible depuis l'extérieur pour que tu puisses accéder à l'interface d'administration de nginx proxy manager
      - "443:443" # il faut que ce port soit accessible depuis l'extérieur pour que tu puisses accéder à tes applications en https
      - "8181:8181" # il faut que ce port soit accessible depuis l'extérieur pour que tu puisses accéder à l'interface d'administration de letsencrypt
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro # alors ça, c'est impératif pour que ça marche. C'est pour que nginx puisse communiquer avec les autres containers
      - /home/ubuntu/volumes/nginx/data:/data # ça, c'est pour que les données de nginx soient persistantes
      - /home/ubuntu/volumes/nginx/certificates:/etc/letsencrypt/ # ça, c'est pour que les certificats soient persistants

# A faire donc en premier : lancer tous les services.
# Ensuite, il faut configurer nginx proxy manager pour qu'il sache où rediriger les requêtes.
# Pour ça, il faut aller sur l'interface d'administration de nginx proxy manager (http://localhost:81 ou http://nom.de.ton.domaine.fr:81)
# tu te connectes avec les identifiants (je noté plus haut les identifiants par défaut, qu'il faudra changer)
# Ensuite, tu vas dans "Proxy Hosts" et tu ajoutes un nouveau proxy host.
# Tu mets le nom de domaine que tu veux (par exemple frapi.local), tu mets le port 8000 (le port sur lequel ton application est exposée dans le container)
# Tu mets l'adresse IP de ton serveur (si tu es en local)
# Tu mets le port 80 (le port sur lequel tu veux accéder à ton application depuis l'extérieur)
# Tu coches "Force SSL" pour que toutes les requêtes soient redirigées en https
# Tu coches "Use Websockets" si ton application utilise des websockets
# Tu coches "Block Common Exploits" pour que nginx proxy manager bloque les requêtes malveillantes
# Tu coches "Forward Hostname" pour que ton application puisse récupérer le nom de domaine utilisé pour accéder à l'application
# Tu coches "Forward Scheme" pour que ton application puisse récupérer le protocole utilisé pour accéder à l'application (http ou https)

# et voilà, t'as plus qu'à demander un certificat à letsencrypt et c'est bon !
# PROMIS c'est simple.

volumes:
  frapi-data:
